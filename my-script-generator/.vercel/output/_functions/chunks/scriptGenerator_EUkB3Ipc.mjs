const categories = {"development":{"name":"Development Tools","icon":"üõ†Ô∏è"},"browsers":{"name":"Web Browsers","icon":"üåê"},"media":{"name":"Media & Graphics","icon":"üé®"},"productivity":{"name":"Productivity","icon":"üìù"},"utilities":{"name":"System Utilities","icon":"‚öôÔ∏è"}};
const applications = {"git":{"name":"Git","description":"Distributed version control system","category":"development","platforms":{"windows":{"winget":"Git.Git","choco":"git"},"macos":{"brew":"git"},"linux":{"ubuntu":"git","fedora":"git","arch":"git","opensuse":"git"}}},"vscode":{"name":"Visual Studio Code","description":"Code editor redefined and optimized","category":"development","platforms":{"windows":{"winget":"Microsoft.VisualStudioCode"},"macos":{"brew":"visual-studio-code","cask":true},"linux":{"ubuntu":"code","snap":"code --classic","fedora":"code","arch":"visual-studio-code-bin","aur":true}}},"firefox":{"name":"Mozilla Firefox","description":"Free and open-source web browser","category":"browsers","platforms":{"windows":{"winget":"Mozilla.Firefox"},"macos":{"brew":"firefox","cask":true},"linux":{"ubuntu":"firefox","fedora":"firefox","arch":"firefox","snap":"firefox"}}},"chrome":{"name":"Google Chrome","description":"Fast, secure web browser","category":"browsers","platforms":{"windows":{"winget":"Google.Chrome"},"macos":{"brew":"google-chrome","cask":true},"linux":{"ubuntu":"google-chrome-stable","fedora":"google-chrome-stable","arch":"google-chrome","aur":true}}},"nodejs":{"name":"Node.js","description":"JavaScript runtime built on Chrome's V8","category":"development","platforms":{"windows":{"winget":"OpenJS.NodeJS"},"macos":{"brew":"node"},"linux":{"ubuntu":"nodejs npm","fedora":"nodejs npm","arch":"nodejs npm"}}},"docker":{"name":"Docker Desktop","description":"Containerization platform","category":"development","platforms":{"windows":{"winget":"Docker.DockerDesktop"},"macos":{"brew":"docker","cask":true},"linux":{"ubuntu":"docker.io","fedora":"docker","arch":"docker"}}},"vlc":{"name":"VLC Media Player","description":"Free and open source cross-platform multimedia player","category":"media","platforms":{"windows":{"winget":"VideoLAN.VLC"},"macos":{"brew":"vlc","cask":true},"linux":{"ubuntu":"vlc","fedora":"vlc","arch":"vlc","snap":"vlc"}}},"7zip":{"name":"7-Zip","description":"File archiver with a high compression ratio","category":"utilities","platforms":{"windows":{"winget":"7zip.7zip"},"macos":{"brew":"sevenzip"},"linux":{"ubuntu":"p7zip-full","fedora":"p7zip","arch":"p7zip"}}}};
const distributions = {"ubuntu":{"name":"Ubuntu / Debian","packageManager":"apt","updateCommand":"sudo apt update && sudo apt upgrade -y"},"fedora":{"name":"Fedora / RHEL / CentOS","packageManager":"dnf","updateCommand":"sudo dnf update -y"},"arch":{"name":"Arch Linux / Manjaro","packageManager":"pacman","updateCommand":"sudo pacman -Syu --noconfirm"},"opensuse":{"name":"openSUSE","packageManager":"zypper","updateCommand":"sudo zypper refresh && sudo zypper update -y"}};
const applicationsData = {
  categories,
  applications,
  distributions,
};

class ScriptGenerator {
  applications;
  distributions;
  constructor() {
    this.applications = applicationsData.applications;
    this.distributions = applicationsData.distributions;
  }
  generateScript(config) {
    const { platform, distribution, selectedApps } = config;
    switch (platform) {
      case "windows":
        return this.generateWindowsScript(selectedApps);
      case "macos":
        return this.generateMacOSScript(selectedApps);
      case "linux":
        return this.generateLinuxScript(selectedApps, distribution);
      default:
        throw new Error(`Unsupported platform: ${platform}`);
    }
  }
  generateWindowsScript(selectedApps) {
    const validApps = selectedApps.filter(
      (appId) => this.applications[appId]?.platforms.windows
    );
    if (validApps.length === 0) {
      return "# No valid applications selected for Windows";
    }
    const header = `# Windows Installation Script
# Generated by Script Installer Generator
# Run this script as Administrator

# Check if running as Administrator
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
{
    Write-Host "This script requires Administrator privileges. Please run as Administrator." -ForegroundColor Red
    exit 1
}

# Set execution policy
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force

# Install winget if not available
if (!(Get-Command winget -ErrorAction SilentlyContinue)) {
    Write-Host "Installing Windows Package Manager (winget)..." -ForegroundColor Yellow
    $progressPreference = 'silentlyContinue'
    Invoke-WebRequest -Uri https://aka.ms/getwinget -OutFile Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
    Add-AppxPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
    Remove-Item Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
}

Write-Host "Starting application installations..." -ForegroundColor Green
`;
    const installations = validApps.map((appId) => {
      const app = this.applications[appId];
      const windowsConfig = app.platforms.windows;
      return `
# Installing ${app.name}
Write-Host "Installing ${app.name}..." -ForegroundColor Cyan
try {
    winget install --id ${windowsConfig.winget} --accept-package-agreements --accept-source-agreements
    Write-Host "${app.name} installed successfully!" -ForegroundColor Green
} catch {
    Write-Host "Failed to install ${app.name}: $_" -ForegroundColor Red
}`;
    }).join("\n");
    const footer = `
Write-Host "Installation script completed!" -ForegroundColor Green
Write-Host "You may need to restart your computer for some applications to work properly." -ForegroundColor Yellow
`;
    return header + installations + footer;
  }
  generateMacOSScript(selectedApps) {
    const validApps = selectedApps.filter(
      (appId) => this.applications[appId]?.platforms.macos
    );
    if (validApps.length === 0) {
      return "# No valid applications selected for macOS";
    }
    const header = `#!/bin/bash
# macOS Installation Script
# Generated by Script Installer Generator

set -e  # Exit on any error

echo "üç∫ macOS Installation Script"
echo "=============================="

# Check if Homebrew is installed
if ! command -v brew &> /dev/null; then
    echo "üì¶ Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

    # Add Homebrew to PATH for Apple Silicon Macs
    if [[ $(uname -m) == "arm64" ]]; then
        echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
    else
        echo 'eval "$(/usr/local/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/usr/local/bin/brew shellenv)"
    fi
else
    echo "üì¶ Updating Homebrew..."
    brew update
fi

echo "üöÄ Starting application installations..."
`;
    const installations = validApps.map((appId) => {
      const app = this.applications[appId];
      const macosConfig = app.platforms.macos;
      const installCommand = macosConfig.cask ? `brew install --cask ${macosConfig.brew}` : `brew install ${macosConfig.brew}`;
      return `
# Installing ${app.name}
echo "üì± Installing ${app.name}..."
if ${installCommand}; then
    echo "‚úÖ ${app.name} installed successfully!"
else
    echo "‚ùå Failed to install ${app.name}"
fi`;
    }).join("\n");
    const footer = `
echo "üéâ Installation script completed!"
echo "All requested applications have been processed."
`;
    return header + installations + footer;
  }
  generateLinuxScript(selectedApps, distribution) {
    if (!distribution) {
      return "# Please select a Linux distribution";
    }
    const validApps = selectedApps.filter(
      (appId) => this.applications[appId]?.platforms.linux?.[distribution]
    );
    if (validApps.length === 0) {
      return `# No valid applications selected for ${distribution}`;
    }
    const distConfig = this.distributions[distribution];
    const header = `#!/bin/bash
# ${distConfig.name} Installation Script
# Generated by Script Installer Generator

set -e  # Exit on any error

echo "üêß ${distConfig.name} Installation Script"
echo "=========================================="

# Update system
echo "üîÑ Updating system packages..."
${distConfig.updateCommand}

echo "üöÄ Starting application installations..."
`;
    const installations = validApps.map((appId) => {
      const app = this.applications[appId];
      const linuxConfig = app.platforms.linux;
      const packageName = linuxConfig[distribution];
      let installCommand;
      switch (distribution) {
        case "ubuntu":
          installCommand = `sudo apt install -y ${packageName}`;
          break;
        case "fedora":
          installCommand = `sudo dnf install -y ${packageName}`;
          break;
        case "arch":
          if (linuxConfig.aur) {
            installCommand = `yay -S --noconfirm ${packageName} || echo "Please install ${packageName} manually from AUR"`;
          } else {
            installCommand = `sudo pacman -S --noconfirm ${packageName}`;
          }
          break;
        case "opensuse":
          installCommand = `sudo zypper install -y ${packageName}`;
          break;
        default:
          installCommand = `echo "Unsupported distribution for ${app.name}"`;
      }
      if (linuxConfig.snap) {
        installCommand += ` && sudo snap install ${linuxConfig.snap}`;
      }
      return `
# Installing ${app.name}
echo "üì¶ Installing ${app.name}..."
if ${installCommand}; then
    echo "‚úÖ ${app.name} installed successfully!"
else
    echo "‚ùå Failed to install ${app.name}"
fi`;
    }).join("\n");
    const footer = `
echo "üéâ Installation script completed!"
echo "All requested applications have been processed."
`;
    return header + installations + footer;
  }
  getApplications() {
    return this.applications;
  }
  getCategories() {
    return applicationsData.categories;
  }
  getDistributions() {
    return this.distributions;
  }
}

export { ScriptGenerator as S };
