import type { Application, Platform, Distribution, ScriptConfig } from './types';
import applicationsData from './applications.json';

export class ScriptGenerator {
  private applications: Record<string, Application>;
  private distributions: Record<string, Distribution>;

  constructor() {
    this.applications = applicationsData.applications as Record<string, Application>;
    this.distributions = applicationsData.distributions as Record<string, Distribution>;
  }

  generateScript(config: ScriptConfig): string {
    const { platform, distribution, selectedApps } = config;

    switch (platform) {
      case 'windows':
        return this.generateWindowsScript(selectedApps);
      case 'macos':
        return this.generateMacOSScript(selectedApps);
      case 'linux':
        return this.generateLinuxScript(selectedApps, distribution);
      default:
        throw new Error(`Unsupported platform: ${platform}`);
    }
  }

  private generateWindowsScript(selectedApps: string[]): string {
    const validApps = selectedApps.filter(appId =>
      this.applications[appId]?.platforms.windows
    );

    if (validApps.length === 0) {
      return '# No valid applications selected for Windows';
    }

    const header = `# Windows Installation Script
# Generated by Script Installer Generator
# Run this script as Administrator

# Check if running as Administrator
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
{
    Write-Host "This script requires Administrator privileges. Please run as Administrator." -ForegroundColor Red
    exit 1
}

# Set execution policy
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force

# Install winget if not available
if (!(Get-Command winget -ErrorAction SilentlyContinue)) {
    Write-Host "Installing Windows Package Manager (winget)..." -ForegroundColor Yellow
    $progressPreference = 'silentlyContinue'
    Invoke-WebRequest -Uri https://aka.ms/getwinget -OutFile Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
    Add-AppxPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
    Remove-Item Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle
}

Write-Host "Starting application installations..." -ForegroundColor Green
`;

    const installations = validApps.map(appId => {
      const app = this.applications[appId];
      const windowsConfig = app.platforms.windows;

      return `
# Installing ${app.name}
Write-Host "Installing ${app.name}..." -ForegroundColor Cyan
try {
    winget install --id ${windowsConfig.winget} --accept-package-agreements --accept-source-agreements
    Write-Host "${app.name} installed successfully!" -ForegroundColor Green
} catch {
    Write-Host "Failed to install ${app.name}: $_" -ForegroundColor Red
}`;
    }).join('\n');

    const footer = `
Write-Host "Installation script completed!" -ForegroundColor Green
Write-Host "You may need to restart your computer for some applications to work properly." -ForegroundColor Yellow
`;

    return header + installations + footer;
  }

  private generateMacOSScript(selectedApps: string[]): string {
    const validApps = selectedApps.filter(appId =>
      this.applications[appId]?.platforms.macos
    );

    if (validApps.length === 0) {
      return '# No valid applications selected for macOS';
    }

    const header = `#!/bin/bash
# macOS Installation Script
# Generated by Script Installer Generator

set -e  # Exit on any error

echo "üç∫ macOS Installation Script"
echo "=============================="

# Check if Homebrew is installed
if ! command -v brew &> /dev/null; then
    echo "üì¶ Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

    # Add Homebrew to PATH for Apple Silicon Macs
    if [[ $(uname -m) == "arm64" ]]; then
        echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
    else
        echo 'eval "$(/usr/local/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/usr/local/bin/brew shellenv)"
    fi
else
    echo "üì¶ Updating Homebrew..."
    brew update
fi

echo "üöÄ Starting application installations..."
`;

    const installations = validApps.map(appId => {
      const app = this.applications[appId];
      const macosConfig = app.platforms.macos;
      const installCommand = macosConfig.cask
        ? `brew install --cask ${macosConfig.brew}`
        : `brew install ${macosConfig.brew}`;

      return `
# Installing ${app.name}
echo "üì± Installing ${app.name}..."
if ${installCommand}; then
    echo "‚úÖ ${app.name} installed successfully!"
else
    echo "‚ùå Failed to install ${app.name}"
fi`;
    }).join('\n');

    const footer = `
echo "üéâ Installation script completed!"
echo "All requested applications have been processed."
`;

    return header + installations + footer;
  }

  private generateLinuxScript(selectedApps: string[], distribution?: string): string {
    if (!distribution) {
      return '# Please select a Linux distribution';
    }

    const validApps = selectedApps.filter(appId =>
      this.applications[appId]?.platforms.linux?.[distribution as keyof typeof this.applications[string]['platforms']['linux']]
    );

    if (validApps.length === 0) {
      return `# No valid applications selected for ${distribution}`;
    }

    const distConfig = this.distributions[distribution];
    const header = `#!/bin/bash
# ${distConfig.name} Installation Script
# Generated by Script Installer Generator

set -e  # Exit on any error

echo "üêß ${distConfig.name} Installation Script"
echo "=========================================="

# Update system
echo "üîÑ Updating system packages..."
${distConfig.updateCommand}

echo "üöÄ Starting application installations..."
`;

    const installations = validApps.map(appId => {
      const app = this.applications[appId];
      const linuxConfig = app.platforms.linux;
      const packageName = linuxConfig[distribution as keyof typeof linuxConfig];

      let installCommand: string;

      switch (distribution) {
        case 'ubuntu':
          installCommand = `sudo apt install -y ${packageName}`;
          break;
        case 'fedora':
          installCommand = `sudo dnf install -y ${packageName}`;
          break;
        case 'arch':
          if (linuxConfig.aur) {
            installCommand = `yay -S --noconfirm ${packageName} || echo "Please install ${packageName} manually from AUR"`;
          } else {
            installCommand = `sudo pacman -S --noconfirm ${packageName}`;
          }
          break;
        case 'opensuse':
          installCommand = `sudo zypper install -y ${packageName}`;
          break;
        default:
          installCommand = `echo "Unsupported distribution for ${app.name}"`;
      }

      if (linuxConfig.snap) {
        installCommand += ` && sudo snap install ${linuxConfig.snap}`;
      }

      return `
# Installing ${app.name}
echo "üì¶ Installing ${app.name}..."
if ${installCommand}; then
    echo "‚úÖ ${app.name} installed successfully!"
else
    echo "‚ùå Failed to install ${app.name}"
fi`;
    }).join('\n');

    const footer = `
echo "üéâ Installation script completed!"
echo "All requested applications have been processed."
`;

    return header + installations + footer;
  }

  getApplications(): Record<string, Application> {
    return this.applications;
  }

  getCategories() {
    return applicationsData.categories;
  }

  getDistributions(): Record<string, Distribution> {
    return this.distributions;
  }
}
